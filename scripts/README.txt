1. Generate all evolutions for all approaches. Within java\Main.scala or codegen\Main.scala you can
   generate all files. The output directories are "ep-scala-XXX" for Scala generated code or "ep-java-XXX"
   for Java-generated code.

   ep-java (GenerateAllMain)
     * System: system-main.json
     * Approaches: graphviz oo visitor visitorSideEffect extensibleVisitor interpreter coco trivially dispatch algebra
     * Evolutions: M0 M1 M2 M3 M4 M5 M6 M7 M7I2 M8 M9 I1 A1 A1M3 A1M3I2 A3 I2 O1 O2 OA O1OA OD1 OD2 OD3 OO1 OO2 OO3

   ep-java-j (GenerateAllJ)
      * System: system-j.json
      * Approaches: graphviz oo visitor visitorSideEffect extensibleVisitor interpreter coco trivially dispatch algebra
      * Evolutions: M0 J1 J2 J3 K1 K2 J4 J5 J6 K2J6 J7 J8

   p-java-d1d2 (GenerateAllD1D2)
      * Approaches: graphviz oo visitor visitorSideEffect extensibleVisitor interpreter coco trivially dispatch algebra
      * Evolutions: M0 M1 D1 D2 D1D2 D3

   ep-java-journal (GenerateAllJournal)
      * Approaches: graphviz oo visitor visitorSideEffect extensibleVisitor interpreter coco trivially dispatch algebra
      * Evolutions: M0 M1 M2 I1 I2 N1 M2_ABS M3 M3I1 I2M3I1N1

   ep-java-producer (GenerateAllProducer)
      * Approaches: graphviz oo visitor visitorSideEffect extensibleVisitor interpreter coco trivially dispatch algebra
      * Evolutions: M0 M1 M2 M3 W1 M3W1 Q1 C2 V1

   ep-java-third-alternate (GenerateAllThirdAlternate)
      * Approaches: graphviz oo visitor visitorSideEffect extensibleVisitor interpreter coco trivially dispatch algebra
      * Evolutions: M0 X1 X2 X3 X2X3 X4

   For Scala-generated code, the above are replaced with "ep-scala-XXX" and approaches and evolutions remain the same.

2. Produce full report to validate which AIPs are truly correct

  c:\Python37\python.exe ..\..\scripts\compare.py ..\..\scripts\systems\[EVOLUTION-JSON] >> REPORT

  Example EVOLUTION-JSON files are "system-j.json" or "system-main.json"

  Note that the JSON files look like the following and contain predecessor information for each EIP to
  make the Python processing a bit easier.

         {
           "evolutions" : [
             { "J1" : ["M0"] },
             { "J2" : ["J1"] },
             ...
          }

  This script assesses whether an approach minimally satisfies the Expression Problem. That is, future evolutions
  do not require any changes to former artifacts.

  This script must be run in the directory that was generated by the above BAT scripts.

  Note that it does not identify situations where, for example, non-trivial code is copied and used in a subsequent
  evolution. For example, the 'interpreter' approach requires code to be copies with producer operations.

     // Within original M4 evolution
     // ------------------------------
     public Exp simplify() {
            if ((Double.valueOf(((Exp) this.left).eval()).equals(0.0) || Double.valueOf(((Exp) this.right).eval()).equals(0.0))) {
                return new Lit(0.0);
            } else if (Double.valueOf(((Exp) this.left).eval()).equals(1.0)) {
                return ((Exp) this.right).simplify();
            } else if (Double.valueOf(((Exp) this.right).eval()).equals(1.0)) {
                return ((Exp) this.left).simplify();
            } else {
                return new ep.m4.Mult(((Exp) this.left).simplify(), ((Exp) this.right).simplify());
            }
        }

     // Within original M7I2 evolution
     // ------------------------------
     public Exp simplify() {
         if ((Double.valueOf(((Exp) this.left).eval()).equals(0.0) || Double.valueOf(((Exp) this.right).eval()).equals(0.0))) {
             return new Lit(0.0);
         } else if (Double.valueOf(((Exp) this.left).eval()).equals(1.0)) {
             return ((Exp) this.right).simplify();
         } else if (Double.valueOf(((Exp) this.right).eval()).equals(1.0)) {
             return ((Exp) this.left).simplify();
         } else {
             return new ep.m7i2.Mult(((Exp) this.left).simplify(), ((Exp) this.right).simplify());
         }
     }

3. Compile and run tests cases to generate jacoco.* code coverage reports.

  On Windows, in the respective "ep-java-XXX" directories you can launch the compilation scripts. For the Scala
  code, replace "java" with "scala" in the commands below.

  * in ep-java                    enter command  "..\..\scripts\java\compile-main.bat"
  * in ep-java-j                  enter command  "..\..\scripts\java\compile-j.bat"
  * in ep-java-journal            enter command  "..\..\scripts\java\compile-journal.bat"
  * in ep-java-d1d2               enter command  "..\..\scripts\java\compile-d1d2.bat"
  * in ep-java-producer           enter command  "..\..\scripts\java\compile-producer.bat"
  * in ep-java-third-alternate    enter command  "..\..\scripts\java\compile-third-alternate.bat"

4. Generate statistics regarding the results of generating the source code, compiling the source code, executing
   the test cases and code coverage statistics. This script also detects errors in these three phases.

   CD into the directory in target\analysis and run the following on each of the jacoco.*** generated files

   c:\Python37\python.exe ..\..\scripts\process.py > STATISTICS

5. When all scripts have run, you may need to delete temporary directories inside of target/bg-jobs that were created
   by SBT (but not deleted). A full run of the scripts often results in several GB worth of directories.
